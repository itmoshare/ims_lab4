                              1 ;--------------------------------------------------------
                              2 ; File Created by SDCC : free open source ANSI-C Compiler
                              3 ; Version 2.9.0 #5416 (Mar 22 2009) (MINGW32)
                              4 ; This file was generated Wed Dec 13 17:04:57 2017
                              5 ;--------------------------------------------------------
                              6 	.module lab4
                              7 	.optsdcc -mmcs51 --model-small
                              8 	
                              9 ;--------------------------------------------------------
                             10 ; Public variables in this module
                             11 ;--------------------------------------------------------
                             12 	.globl _EOL
                             13 	.globl _main
                             14 	.globl _print_result
                             15 	.globl _print_num
                             16 	.globl _print_error
                             17 	.globl _init_kb_timer
                             18 	.globl _timer_kb
                             19 	.globl _scan_row
                             20 	.globl _invalid_input
                             21 	.globl _get_input
                             22 	.globl _capture_input
                             23 	.globl _is_queue_empty
                             24 	.globl _leds
                             25 	.globl _led
                             26 	.globl _readdip
                             27 	.globl _read_max
                             28 	.globl _write_max
                             29 	.globl _SetVector
                             30 	.globl _SPR0
                             31 	.globl _SPR1
                             32 	.globl _CPHA
                             33 	.globl _CPOL
                             34 	.globl _SPIM
                             35 	.globl _SPE
                             36 	.globl _WCOL
                             37 	.globl _ISPI
                             38 	.globl _I2CI
                             39 	.globl _I2CTX
                             40 	.globl _I2CRS
                             41 	.globl _I2CM
                             42 	.globl _MDI
                             43 	.globl _MCO
                             44 	.globl _MDE
                             45 	.globl _MDO
                             46 	.globl _CS0
                             47 	.globl _CS1
                             48 	.globl _CS2
                             49 	.globl _CS3
                             50 	.globl _SCONV
                             51 	.globl _CCONV
                             52 	.globl _DMA
                             53 	.globl _ADCI
                             54 	.globl _P
                             55 	.globl _F1
                             56 	.globl _OV
                             57 	.globl _RS0
                             58 	.globl _RS1
                             59 	.globl _F0
                             60 	.globl _AC
                             61 	.globl _CY
                             62 	.globl _CAP2
                             63 	.globl _CNT2
                             64 	.globl _TR2
                             65 	.globl _XEN
                             66 	.globl _TCLK
                             67 	.globl _RCLK
                             68 	.globl _EXF2
                             69 	.globl _TF2
                             70 	.globl _WDE
                             71 	.globl _WDS
                             72 	.globl _WDR2
                             73 	.globl _WDR1
                             74 	.globl _PRE0
                             75 	.globl _PRE1
                             76 	.globl _PRE2
                             77 	.globl _PX0
                             78 	.globl _PT0
                             79 	.globl _PX1
                             80 	.globl _PT1
                             81 	.globl _PS
                             82 	.globl _PT2
                             83 	.globl _PADC
                             84 	.globl _PSI
                             85 	.globl _RXD
                             86 	.globl _TXD
                             87 	.globl _INT0
                             88 	.globl _INT1
                             89 	.globl _T0
                             90 	.globl _T1
                             91 	.globl _WR
                             92 	.globl _RD
                             93 	.globl _EX0
                             94 	.globl _ET0
                             95 	.globl _EX1
                             96 	.globl _ET1
                             97 	.globl _ES
                             98 	.globl _ET2
                             99 	.globl _EADC
                            100 	.globl _EA
                            101 	.globl _RI
                            102 	.globl _TI
                            103 	.globl _RB8
                            104 	.globl _TB8
                            105 	.globl _REN
                            106 	.globl _SM2
                            107 	.globl _SM1
                            108 	.globl _SM0
                            109 	.globl _T2
                            110 	.globl _T2EX
                            111 	.globl _IT0
                            112 	.globl _IE0
                            113 	.globl _IT1
                            114 	.globl _IE1
                            115 	.globl _TR0
                            116 	.globl _TF0
                            117 	.globl _TR1
                            118 	.globl _TF1
                            119 	.globl _DACCON
                            120 	.globl _DAC1H
                            121 	.globl _DAC1L
                            122 	.globl _DAC0H
                            123 	.globl _DAC0L
                            124 	.globl _SPICON
                            125 	.globl _SPIDAT
                            126 	.globl _ADCCON3
                            127 	.globl _ADCGAINH
                            128 	.globl _ADCGAINL
                            129 	.globl _ADCOFSH
                            130 	.globl _ADCOFSL
                            131 	.globl _B
                            132 	.globl _ADCCON1
                            133 	.globl _I2CCON
                            134 	.globl _ACC
                            135 	.globl _PSMCON
                            136 	.globl _ADCDATAH
                            137 	.globl _ADCDATAL
                            138 	.globl _ADCCON2
                            139 	.globl _DMAP
                            140 	.globl _DMAH
                            141 	.globl _DMAL
                            142 	.globl _PSW
                            143 	.globl _TH2
                            144 	.globl _TL2
                            145 	.globl _RCAP2H
                            146 	.globl _RCAP2L
                            147 	.globl _T2CON
                            148 	.globl _EADRL
                            149 	.globl _WDCON
                            150 	.globl _EDATA4
                            151 	.globl _EDATA3
                            152 	.globl _EDATA2
                            153 	.globl _EDATA1
                            154 	.globl _ETIM3
                            155 	.globl _ETIM2
                            156 	.globl _ETIM1
                            157 	.globl _ECON
                            158 	.globl _IP
                            159 	.globl _P3
                            160 	.globl _IE2
                            161 	.globl _IE
                            162 	.globl _P2
                            163 	.globl _I2CADD
                            164 	.globl _I2CDAT
                            165 	.globl _SBUF
                            166 	.globl _SCON
                            167 	.globl _P1
                            168 	.globl _TH1
                            169 	.globl _TH0
                            170 	.globl _TL1
                            171 	.globl _TL0
                            172 	.globl _TMOD
                            173 	.globl _TCON
                            174 	.globl _PCON
                            175 	.globl _DPP
                            176 	.globl _DPH
                            177 	.globl _DPL
                            178 	.globl _SP
                            179 	.globl _P0
                            180 	.globl _state
                            181 	.globl _second_num
                            182 	.globl _first_num
                            183 	.globl _second_size
                            184 	.globl _first_size
                            185 	.globl _ir
                            186 	.globl _READ_FIFO
                            187 	.globl _keyboard
                            188 	.globl _end_queue
                            189 	.globl _start_queue
                            190 	.globl _queue
                            191 	.globl _time
                            192 	.globl _bounce
                            193 	.globl _column
                            194 	.globl _uart_s_init
                            195 	.globl _uart_s_read_ready
                            196 	.globl _uart_s_write
                            197 	.globl _uart_s_read
                            198 	.globl _type
                            199 ;--------------------------------------------------------
                            200 ; special function registers
                            201 ;--------------------------------------------------------
                            202 	.area RSEG    (DATA)
                    0080    203 _P0	=	0x0080
                    0081    204 _SP	=	0x0081
                    0082    205 _DPL	=	0x0082
                    0083    206 _DPH	=	0x0083
                    0084    207 _DPP	=	0x0084
                    0087    208 _PCON	=	0x0087
                    0088    209 _TCON	=	0x0088
                    0089    210 _TMOD	=	0x0089
                    008A    211 _TL0	=	0x008a
                    008B    212 _TL1	=	0x008b
                    008C    213 _TH0	=	0x008c
                    008D    214 _TH1	=	0x008d
                    0090    215 _P1	=	0x0090
                    0098    216 _SCON	=	0x0098
                    0099    217 _SBUF	=	0x0099
                    009A    218 _I2CDAT	=	0x009a
                    009B    219 _I2CADD	=	0x009b
                    00A0    220 _P2	=	0x00a0
                    00A8    221 _IE	=	0x00a8
                    00A9    222 _IE2	=	0x00a9
                    00B0    223 _P3	=	0x00b0
                    00B8    224 _IP	=	0x00b8
                    00B9    225 _ECON	=	0x00b9
                    00BA    226 _ETIM1	=	0x00ba
                    00BB    227 _ETIM2	=	0x00bb
                    00C4    228 _ETIM3	=	0x00c4
                    00BC    229 _EDATA1	=	0x00bc
                    00BD    230 _EDATA2	=	0x00bd
                    00BE    231 _EDATA3	=	0x00be
                    00BF    232 _EDATA4	=	0x00bf
                    00C0    233 _WDCON	=	0x00c0
                    00C6    234 _EADRL	=	0x00c6
                    00C8    235 _T2CON	=	0x00c8
                    00CA    236 _RCAP2L	=	0x00ca
                    00CB    237 _RCAP2H	=	0x00cb
                    00CC    238 _TL2	=	0x00cc
                    00CD    239 _TH2	=	0x00cd
                    00D0    240 _PSW	=	0x00d0
                    00D2    241 _DMAL	=	0x00d2
                    00D3    242 _DMAH	=	0x00d3
                    00D4    243 _DMAP	=	0x00d4
                    00D8    244 _ADCCON2	=	0x00d8
                    00D9    245 _ADCDATAL	=	0x00d9
                    00DA    246 _ADCDATAH	=	0x00da
                    00DF    247 _PSMCON	=	0x00df
                    00E0    248 _ACC	=	0x00e0
                    00E8    249 _I2CCON	=	0x00e8
                    00EF    250 _ADCCON1	=	0x00ef
                    00F0    251 _B	=	0x00f0
                    00F1    252 _ADCOFSL	=	0x00f1
                    00F2    253 _ADCOFSH	=	0x00f2
                    00F3    254 _ADCGAINL	=	0x00f3
                    00F4    255 _ADCGAINH	=	0x00f4
                    00F5    256 _ADCCON3	=	0x00f5
                    00F7    257 _SPIDAT	=	0x00f7
                    00F8    258 _SPICON	=	0x00f8
                    00F9    259 _DAC0L	=	0x00f9
                    00FA    260 _DAC0H	=	0x00fa
                    00FB    261 _DAC1L	=	0x00fb
                    00FC    262 _DAC1H	=	0x00fc
                    00FD    263 _DACCON	=	0x00fd
                            264 ;--------------------------------------------------------
                            265 ; special function bits
                            266 ;--------------------------------------------------------
                            267 	.area RSEG    (DATA)
                    008F    268 _TF1	=	0x008f
                    008E    269 _TR1	=	0x008e
                    008D    270 _TF0	=	0x008d
                    008C    271 _TR0	=	0x008c
                    008B    272 _IE1	=	0x008b
                    008A    273 _IT1	=	0x008a
                    0089    274 _IE0	=	0x0089
                    0088    275 _IT0	=	0x0088
                    0091    276 _T2EX	=	0x0091
                    0090    277 _T2	=	0x0090
                    009F    278 _SM0	=	0x009f
                    009E    279 _SM1	=	0x009e
                    009D    280 _SM2	=	0x009d
                    009C    281 _REN	=	0x009c
                    009B    282 _TB8	=	0x009b
                    009A    283 _RB8	=	0x009a
                    0099    284 _TI	=	0x0099
                    0098    285 _RI	=	0x0098
                    00AF    286 _EA	=	0x00af
                    00AE    287 _EADC	=	0x00ae
                    00AD    288 _ET2	=	0x00ad
                    00AC    289 _ES	=	0x00ac
                    00AB    290 _ET1	=	0x00ab
                    00AA    291 _EX1	=	0x00aa
                    00A9    292 _ET0	=	0x00a9
                    00A8    293 _EX0	=	0x00a8
                    00B7    294 _RD	=	0x00b7
                    00B6    295 _WR	=	0x00b6
                    00B5    296 _T1	=	0x00b5
                    00B4    297 _T0	=	0x00b4
                    00B3    298 _INT1	=	0x00b3
                    00B2    299 _INT0	=	0x00b2
                    00B1    300 _TXD	=	0x00b1
                    00B0    301 _RXD	=	0x00b0
                    00BF    302 _PSI	=	0x00bf
                    00BE    303 _PADC	=	0x00be
                    00BD    304 _PT2	=	0x00bd
                    00BC    305 _PS	=	0x00bc
                    00BB    306 _PT1	=	0x00bb
                    00BA    307 _PX1	=	0x00ba
                    00B9    308 _PT0	=	0x00b9
                    00B8    309 _PX0	=	0x00b8
                    00C7    310 _PRE2	=	0x00c7
                    00C6    311 _PRE1	=	0x00c6
                    00C5    312 _PRE0	=	0x00c5
                    00C3    313 _WDR1	=	0x00c3
                    00C2    314 _WDR2	=	0x00c2
                    00C1    315 _WDS	=	0x00c1
                    00C0    316 _WDE	=	0x00c0
                    00CF    317 _TF2	=	0x00cf
                    00CE    318 _EXF2	=	0x00ce
                    00CD    319 _RCLK	=	0x00cd
                    00CC    320 _TCLK	=	0x00cc
                    00CB    321 _XEN	=	0x00cb
                    00CA    322 _TR2	=	0x00ca
                    00C9    323 _CNT2	=	0x00c9
                    00C8    324 _CAP2	=	0x00c8
                    00D7    325 _CY	=	0x00d7
                    00D6    326 _AC	=	0x00d6
                    00D5    327 _F0	=	0x00d5
                    00D4    328 _RS1	=	0x00d4
                    00D3    329 _RS0	=	0x00d3
                    00D2    330 _OV	=	0x00d2
                    00D1    331 _F1	=	0x00d1
                    00D0    332 _P	=	0x00d0
                    00DF    333 _ADCI	=	0x00df
                    00DE    334 _DMA	=	0x00de
                    00DD    335 _CCONV	=	0x00dd
                    00DC    336 _SCONV	=	0x00dc
                    00DB    337 _CS3	=	0x00db
                    00DA    338 _CS2	=	0x00da
                    00D9    339 _CS1	=	0x00d9
                    00D8    340 _CS0	=	0x00d8
                    00EF    341 _MDO	=	0x00ef
                    00EE    342 _MDE	=	0x00ee
                    00ED    343 _MCO	=	0x00ed
                    00EC    344 _MDI	=	0x00ec
                    00EB    345 _I2CM	=	0x00eb
                    00EA    346 _I2CRS	=	0x00ea
                    00E9    347 _I2CTX	=	0x00e9
                    00E8    348 _I2CI	=	0x00e8
                    00FF    349 _ISPI	=	0x00ff
                    00FE    350 _WCOL	=	0x00fe
                    00FD    351 _SPE	=	0x00fd
                    00FC    352 _SPIM	=	0x00fc
                    00FB    353 _CPOL	=	0x00fb
                    00FA    354 _CPHA	=	0x00fa
                    00F9    355 _SPR1	=	0x00f9
                    00F8    356 _SPR0	=	0x00f8
                            357 ;--------------------------------------------------------
                            358 ; overlayable register banks
                            359 ;--------------------------------------------------------
                            360 	.area REG_BANK_0	(REL,OVR,DATA)
   0000                     361 	.ds 8
                            362 ;--------------------------------------------------------
                            363 ; overlayable bit register bank
                            364 ;--------------------------------------------------------
                            365 	.area BIT_BANK	(REL,OVR,DATA)
   0000                     366 bits:
   0000                     367 	.ds 1
                    8000    368 	b0 = bits[0]
                    8100    369 	b1 = bits[1]
                    8200    370 	b2 = bits[2]
                    8300    371 	b3 = bits[3]
                    8400    372 	b4 = bits[4]
                    8500    373 	b5 = bits[5]
                    8600    374 	b6 = bits[6]
                    8700    375 	b7 = bits[7]
                            376 ;--------------------------------------------------------
                            377 ; internal ram data
                            378 ;--------------------------------------------------------
                            379 	.area DSEG    (DATA)
   0000                     380 _old_led:
   0000                     381 	.ds 1
   0001                     382 _column::
   0001                     383 	.ds 1
   0002                     384 _bounce::
   0002                     385 	.ds 16
   0012                     386 _time::
   0012                     387 	.ds 32
   0032                     388 _queue::
   0032                     389 	.ds 10
   003C                     390 _start_queue::
   003C                     391 	.ds 1
   003D                     392 _end_queue::
   003D                     393 	.ds 1
   003E                     394 _keyboard::
   003E                     395 	.ds 16
   004E                     396 _READ_FIFO::
   004E                     397 	.ds 8
   0056                     398 _ir::
   0056                     399 	.ds 1
   0057                     400 _first_size::
   0057                     401 	.ds 1
   0058                     402 _second_size::
   0058                     403 	.ds 1
   0059                     404 _first_num::
   0059                     405 	.ds 1
   005A                     406 _second_num::
   005A                     407 	.ds 1
   005B                     408 _state::
   005B                     409 	.ds 1
                            410 ;--------------------------------------------------------
                            411 ; overlayable items in internal ram 
                            412 ;--------------------------------------------------------
                            413 	.area OSEG    (OVR,DATA)
                            414 ;--------------------------------------------------------
                            415 ; Stack segment in internal ram 
                            416 ;--------------------------------------------------------
                            417 	.area	SSEG	(DATA)
   0000                     418 __start__stack:
   0000                     419 	.ds	1
                            420 
                            421 ;--------------------------------------------------------
                            422 ; indirectly addressable internal ram data
                            423 ;--------------------------------------------------------
                            424 	.area ISEG    (DATA)
                            425 ;--------------------------------------------------------
                            426 ; absolute internal ram data
                            427 ;--------------------------------------------------------
                            428 	.area IABS    (ABS,DATA)
                            429 	.area IABS    (ABS,DATA)
                            430 ;--------------------------------------------------------
                            431 ; bit data
                            432 ;--------------------------------------------------------
                            433 	.area BSEG    (BIT)
                            434 ;--------------------------------------------------------
                            435 ; paged external ram data
                            436 ;--------------------------------------------------------
                            437 	.area PSEG    (PAG,XDATA)
                            438 ;--------------------------------------------------------
                            439 ; external ram data
                            440 ;--------------------------------------------------------
                            441 	.area XSEG    (XDATA)
                            442 ;--------------------------------------------------------
                            443 ; absolute external ram data
                            444 ;--------------------------------------------------------
                            445 	.area XABS    (ABS,XDATA)
                            446 ;--------------------------------------------------------
                            447 ; external initialized ram data
                            448 ;--------------------------------------------------------
                            449 	.area XISEG   (XDATA)
                            450 	.area HOME    (CODE)
                            451 	.area GSINIT0 (CODE)
                            452 	.area GSINIT1 (CODE)
                            453 	.area GSINIT2 (CODE)
                            454 	.area GSINIT3 (CODE)
                            455 	.area GSINIT4 (CODE)
                            456 	.area GSINIT5 (CODE)
                            457 	.area GSINIT  (CODE)
                            458 	.area GSFINAL (CODE)
                            459 	.area CSEG    (CODE)
                            460 ;--------------------------------------------------------
                            461 ; interrupt vector 
                            462 ;--------------------------------------------------------
                            463 	.area HOME    (CODE)
   0000                     464 __interrupt_vect:
   0000 02s00r00            465 	ljmp	__sdcc_gsinit_startup
   0003 32                  466 	reti
   0004                     467 	.ds	7
   000B 02s01rC2            468 	ljmp	_timer_kb
                            469 ;--------------------------------------------------------
                            470 ; global & static initialisations
                            471 ;--------------------------------------------------------
                            472 	.area HOME    (CODE)
                            473 	.area GSINIT  (CODE)
                            474 	.area GSFINAL (CODE)
                            475 	.area GSINIT  (CODE)
                            476 	.globl __sdcc_gsinit_startup
                            477 	.globl __sdcc_program_startup
                            478 	.globl __start__stack
                            479 	.globl __mcs51_genXINIT
                            480 	.globl __mcs51_genXRAMCLEAR
                            481 	.globl __mcs51_genRAMCLEAR
                            482 ;	./include/led.h:6: static unsigned char old_led = 0;   // "Видеопамять" линейки светодиодов
   0000 75*00 00            483 	mov	_old_led,#0x00
                            484 ;	./include/kb.h:11: unsigned char column = 3;
   0003 75*01 03            485 	mov	_column,#0x03
                            486 ;	./include/kb.h:12: unsigned char bounce[4][4] = {{0}};
   0006 75*02 00            487 	mov	_bounce,#0x00
                            488 ;	./include/kb.h:13: unsigned short time[4][4] = {{0}};
   0009 75*12 00            489 	mov	_time,#0x00
   000C 75*13 00            490 	mov	(_time + 1),#0x00
                            491 ;	./include/kb.h:14: unsigned char queue[QUEUE_LENGTH] = {0};
   000F 75*32 00            492 	mov	_queue,#0x00
                            493 ;	./include/kb.h:15: char start_queue = 0, end_queue = 0;
   0012 75*3C 00            494 	mov	_start_queue,#0x00
                            495 ;	./include/kb.h:15: unsigned char keyboard[4][4] = {
   0015 75*3D 00            496 	mov	_end_queue,#0x00
                            497 ;	./include/kb.h:16: {'1', '2', '3', 'A'},
   0018 75*3E 31            498 	mov	_keyboard,#0x31
   001B 75*3F 32            499 	mov	(_keyboard + 0x0001),#0x32
   001E 75*40 33            500 	mov	(_keyboard + 0x0002),#0x33
   0021 75*41 41            501 	mov	(_keyboard + 0x0003),#0x41
   0024 75*42 34            502 	mov	(_keyboard + 0x0004),#0x34
   0027 75*43 35            503 	mov	(_keyboard + 0x0005),#0x35
   002A 75*44 36            504 	mov	(_keyboard + 0x0006),#0x36
   002D 75*45 42            505 	mov	(_keyboard + 0x0007),#0x42
   0030 75*46 37            506 	mov	(_keyboard + 0x0008),#0x37
   0033 75*47 38            507 	mov	(_keyboard + 0x0009),#0x38
   0036 75*48 39            508 	mov	(_keyboard + 0x000a),#0x39
   0039 75*49 43            509 	mov	(_keyboard + 0x000b),#0x43
   003C 75*4A 2A            510 	mov	(_keyboard + 0x000c),#0x2A
   003F 75*4B 30            511 	mov	(_keyboard + 0x000d),#0x30
   0042 75*4C 23            512 	mov	(_keyboard + 0x000e),#0x23
   0045 75*4D 44            513 	mov	(_keyboard + 0x000f),#0x44
                            514 ;	src/lab4.c:19: unsigned char READ_FIFO[BUFFSZ] = {0};
   0048 75*4E 00            515 	mov	_READ_FIFO,#0x00
                            516 ;	src/lab4.c:20: unsigned char ir = 0;
   004B 75*56 00            517 	mov	_ir,#0x00
                            518 ;	src/lab4.c:22: unsigned char first_size = 0;
   004E 75*57 00            519 	mov	_first_size,#0x00
                            520 ;	src/lab4.c:23: unsigned char second_size = 0;
   0051 75*58 00            521 	mov	_second_size,#0x00
                            522 ;	src/lab4.c:24: char first_num = -1;
   0054 75*59 FF            523 	mov	_first_num,#0xFF
                            524 ;	src/lab4.c:25: char second_num = -1;
   0057 75*5A FF            525 	mov	_second_num,#0xFF
                            526 ;	src/lab4.c:27: unsigned char state = 0;
   005A 75*5B 00            527 	mov	_state,#0x00
                            528 	.area GSFINAL (CODE)
   0000 02s00r0E            529 	ljmp	__sdcc_program_startup
                            530 ;--------------------------------------------------------
                            531 ; Home
                            532 ;--------------------------------------------------------
                            533 	.area HOME    (CODE)
                            534 	.area HOME    (CODE)
   000E                     535 __sdcc_program_startup:
   000E 12s06r29            536 	lcall	_main
                            537 ;	return from main will lock up
   0011 80 FE               538 	sjmp .
                            539 ;--------------------------------------------------------
                            540 ; code
                            541 ;--------------------------------------------------------
                            542 	.area CSEG    (CODE)
                            543 ;------------------------------------------------------------
                            544 ;Allocation info for local variables in function 'SetVector'
                            545 ;------------------------------------------------------------
                            546 ;Vector                    Allocated to stack - offset -5
                            547 ;Address                   Allocated to registers r2 r3 
                            548 ;TmpVector                 Allocated to registers r2 r3 
                            549 ;------------------------------------------------------------
                            550 ;	./include/interrupt.h:13: void SetVector(unsigned char xdata * Address, void * Vector) {
                            551 ;	-----------------------------------------
                            552 ;	 function SetVector
                            553 ;	-----------------------------------------
   0000                     554 _SetVector:
                    0002    555 	ar2 = 0x02
                    0003    556 	ar3 = 0x03
                    0004    557 	ar4 = 0x04
                    0005    558 	ar5 = 0x05
                    0006    559 	ar6 = 0x06
                    0007    560 	ar7 = 0x07
                    0000    561 	ar0 = 0x00
                    0001    562 	ar1 = 0x01
   0000 C0*00               563 	push	_bp
   0002 85 81*00            564 	mov	_bp,sp
                            565 ;	./include/interrupt.h:16: *Address = 0x02;
   0005 AA 82               566 	mov	r2,dpl
   0007 AB 83               567 	mov  r3,dph
   0009 74 02               568 	mov	a,#0x02
   000B F0                  569 	movx	@dptr,a
                            570 ;	./include/interrupt.h:18: TmpVector = (unsigned char xdata *) (Address + 1);
   000C 0A                  571 	inc	r2
   000D BA 00 01            572 	cjne	r2,#0x00,00103$
   0010 0B                  573 	inc	r3
   0011                     574 00103$:
                            575 ;	./include/interrupt.h:19: *TmpVector = (unsigned char) ((unsigned short)Vector >> 8);
   0011 E5*00               576 	mov	a,_bp
   0013 24 FB               577 	add	a,#0xfb
   0015 F8                  578 	mov	r0,a
   0016 86 04               579 	mov	ar4,@r0
   0018 08                  580 	inc	r0
   0019 86 05               581 	mov	ar5,@r0
   001B 8D 04               582 	mov	ar4,r5
   001D 8A 82               583 	mov	dpl,r2
   001F 8B 83               584 	mov	dph,r3
   0021 EC                  585 	mov	a,r4
   0022 F0                  586 	movx	@dptr,a
   0023 A3                  587 	inc	dptr
   0024 AA 82               588 	mov	r2,dpl
   0026 AB 83               589 	mov	r3,dph
                            590 ;	./include/interrupt.h:20: ++TmpVector;
                            591 ;	./include/interrupt.h:21: *TmpVector = (unsigned char) Vector;
   0028 E5*00               592 	mov	a,_bp
   002A 24 FB               593 	add	a,#0xfb
   002C F8                  594 	mov	r0,a
   002D 86 04               595 	mov	ar4,@r0
   002F 8A 82               596 	mov	dpl,r2
   0031 8B 83               597 	mov	dph,r3
   0033 EC                  598 	mov	a,r4
   0034 F0                  599 	movx	@dptr,a
   0035 D0*00               600 	pop	_bp
   0037 22                  601 	ret
                            602 ;------------------------------------------------------------
                            603 ;Allocation info for local variables in function 'write_max'
                            604 ;------------------------------------------------------------
                            605 ;val                       Allocated to stack - offset -3
                            606 ;regnum                    Allocated to registers r2 r3 
                            607 ;oldDPP                    Allocated to registers r4 
                            608 ;------------------------------------------------------------
                            609 ;	./include/max.h:20: void write_max( unsigned char xdata *regnum, unsigned char val ) {
                            610 ;	-----------------------------------------
                            611 ;	 function write_max
                            612 ;	-----------------------------------------
   0038                     613 _write_max:
   0038 C0*00               614 	push	_bp
   003A 85 81*00            615 	mov	_bp,sp
                            616 ;	./include/max.h:21: unsigned char oldDPP = DPP;
                            617 ;	./include/max.h:22: DPP     = MAXBASE;
                            618 ;	./include/max.h:23: *regnum = val;
   003D AC 84               619 	mov	r4,_DPP
   003F 75 84 08            620 	mov	_DPP,#0x08
   0042 A8*00               621 	mov	r0,_bp
   0044 18                  622 	dec	r0
   0045 18                  623 	dec	r0
   0046 18                  624 	dec	r0
   0047 E6                  625 	mov	a,@r0
   0048 F0                  626 	movx	@dptr,a
                            627 ;	./include/max.h:24: DPP     = oldDPP;
   0049 8C 84               628 	mov	_DPP,r4
   004B D0*00               629 	pop	_bp
   004D 22                  630 	ret
                            631 ;------------------------------------------------------------
                            632 ;Allocation info for local variables in function 'read_max'
                            633 ;------------------------------------------------------------
                            634 ;regnum                    Allocated to registers r2 r3 
                            635 ;oldDPP                    Allocated to registers r4 
                            636 ;val                       Allocated to registers r2 
                            637 ;------------------------------------------------------------
                            638 ;	./include/max.h:27: unsigned char read_max( unsigned char xdata *regnum ) {
                            639 ;	-----------------------------------------
                            640 ;	 function read_max
                            641 ;	-----------------------------------------
   004E                     642 _read_max:
                            643 ;	./include/max.h:28: unsigned char oldDPP=DPP;
                            644 ;	./include/max.h:31: DPP = MAXBASE;
                            645 ;	./include/max.h:32: val = *regnum;
   004E AC 84               646 	mov	r4,_DPP
   0050 75 84 08            647 	mov	_DPP,#0x08
   0053 E0                  648 	movx	a,@dptr
   0054 FA                  649 	mov	r2,a
                            650 ;	./include/max.h:33: DPP = oldDPP;
   0055 8C 84               651 	mov	_DPP,r4
                            652 ;	./include/max.h:35: return val;
   0057 8A 82               653 	mov	dpl,r2
   0059 22                  654 	ret
                            655 ;------------------------------------------------------------
                            656 ;Allocation info for local variables in function 'readdip'
                            657 ;------------------------------------------------------------
                            658 ;------------------------------------------------------------
                            659 ;	./include/max.h:38: unsigned char readdip() {
                            660 ;	-----------------------------------------
                            661 ;	 function readdip
                            662 ;	-----------------------------------------
   005A                     663 _readdip:
                            664 ;	./include/max.h:39: write_max(ENA, 0x00);
   005A E4                  665 	clr	a
   005B C0 E0               666 	push	acc
   005D 90 00 04            667 	mov	dptr,#0x0004
   0060 12s00r38            668 	lcall	_write_max
   0063 15 81               669 	dec	sp
                            670 ;	./include/max.h:40: return read_max(EXT_LO);
   0065 90 00 02            671 	mov	dptr,#0x0002
   0068 02s00r4E            672 	ljmp	_read_max
                            673 ;------------------------------------------------------------
                            674 ;Allocation info for local variables in function 'led'
                            675 ;------------------------------------------------------------
                            676 ;on                        Allocated to stack - offset -3
                            677 ;n                         Allocated to registers r2 
                            678 ;c                         Allocated to registers r3 
                            679 ;mask                      Allocated to registers r2 
                            680 ;------------------------------------------------------------
                            681 ;	./include/led.h:9: void led( unsigned char n, unsigned char on )
                            682 ;	-----------------------------------------
                            683 ;	 function led
                            684 ;	-----------------------------------------
   006B                     685 _led:
   006B C0*00               686 	push	_bp
   006D 85 81*00            687 	mov	_bp,sp
                            688 ;	./include/led.h:14: if( n > 7 ) return;
   0070 E5 82               689 	mov	a,dpl
   0072 FA                  690 	mov	r2,a
   0073 24 F8               691 	add	a,#0xff - 0x07
   0075 50 02               692 	jnc	00102$
   0077 80 32               693 	sjmp	00106$
   0079                     694 00102$:
                            695 ;	./include/led.h:16: c = old_led;
   0079 AB*00               696 	mov	r3,_old_led
                            697 ;	./include/led.h:18: mask <<= n;
   007B 8A F0               698 	mov	b,r2
   007D 05 F0               699 	inc	b
   007F 74 01               700 	mov	a,#0x01
   0081 80 02               701 	sjmp	00113$
   0083                     702 00111$:
   0083 25 E0               703 	add	a,acc
   0085                     704 00113$:
   0085 D5 F0 FB            705 	djnz	b,00111$
   0088 FA                  706 	mov	r2,a
                            707 ;	./include/led.h:20: if( on )
   0089 A8*00               708 	mov	r0,_bp
   008B 18                  709 	dec	r0
   008C 18                  710 	dec	r0
   008D 18                  711 	dec	r0
   008E E6                  712 	mov	a,@r0
   008F 60 05               713 	jz	00104$
                            714 ;	./include/led.h:21: c |= mask;
   0091 EA                  715 	mov	a,r2
   0092 42 03               716 	orl	ar3,a
   0094 80 05               717 	sjmp	00105$
   0096                     718 00104$:
                            719 ;	./include/led.h:23: c &= ~mask;         
   0096 EA                  720 	mov	a,r2
   0097 F4                  721 	cpl	a
   0098 FA                  722 	mov	r2,a
   0099 52 03               723 	anl	ar3,a
   009B                     724 00105$:
                            725 ;	./include/led.h:25: write_max( SV, c );     
   009B C0 03               726 	push	ar3
   009D C0 03               727 	push	ar3
   009F 90 00 07            728 	mov	dptr,#0x0007
   00A2 12s00r38            729 	lcall	_write_max
   00A5 15 81               730 	dec	sp
   00A7 D0 03               731 	pop	ar3
                            732 ;	./include/led.h:27: old_led = c;
   00A9 8B*00               733 	mov	_old_led,r3
   00AB                     734 00106$:
   00AB D0*00               735 	pop	_bp
   00AD 22                  736 	ret
                            737 ;------------------------------------------------------------
                            738 ;Allocation info for local variables in function 'leds'
                            739 ;------------------------------------------------------------
                            740 ;on                        Allocated to registers r2 
                            741 ;------------------------------------------------------------
                            742 ;	./include/led.h:30: void leds( unsigned char on ) {
                            743 ;	-----------------------------------------
                            744 ;	 function leds
                            745 ;	-----------------------------------------
   00AE                     746 _leds:
   00AE AA 82               747 	mov	r2,dpl
                            748 ;	./include/led.h:31: write_max( SV, on );     
   00B0 C0 02               749 	push	ar2
   00B2 C0 02               750 	push	ar2
   00B4 90 00 07            751 	mov	dptr,#0x0007
   00B7 12s00r38            752 	lcall	_write_max
   00BA 15 81               753 	dec	sp
   00BC D0 02               754 	pop	ar2
                            755 ;	./include/led.h:32: old_led = on;
   00BE 8A*00               756 	mov	_old_led,r2
   00C0 22                  757 	ret
                            758 ;------------------------------------------------------------
                            759 ;Allocation info for local variables in function 'uart_s_init'
                            760 ;------------------------------------------------------------
                            761 ;speed                     Allocated to registers r2 r3 
                            762 ;------------------------------------------------------------
                            763 ;	./include/serial.h:21: void uart_s_init(int speed) {
                            764 ;	-----------------------------------------
                            765 ;	 function uart_s_init
                            766 ;	-----------------------------------------
   00C1                     767 _uart_s_init:
   00C1 AA 82               768 	mov	r2,dpl
                            769 ;	./include/serial.h:22: TH1 = speed;   
   00C3 8A 8D               770 	mov	_TH1,r2
                            771 ;	./include/serial.h:23: TMOD |= 0x20; // Таймер 1 будет работать в режиме autoreload
   00C5 43 89 20            772 	orl	_TMOD,#0x20
                            773 ;	./include/serial.h:24: TR1 = 1;      // start T1
   00C8 D2 8E               774 	setb	_TR1
                            775 ;	./include/serial.h:25: SCON = 0x50;  // REN = 1, UART mode 1
   00CA 75 98 50            776 	mov	_SCON,#0x50
   00CD 22                  777 	ret
                            778 ;------------------------------------------------------------
                            779 ;Allocation info for local variables in function 'uart_s_read_ready'
                            780 ;------------------------------------------------------------
                            781 ;------------------------------------------------------------
                            782 ;	./include/serial.h:28: unsigned char uart_s_read_ready() {
                            783 ;	-----------------------------------------
                            784 ;	 function uart_s_read_ready
                            785 ;	-----------------------------------------
   00CE                     786 _uart_s_read_ready:
                            787 ;	./include/serial.h:29: return RI;
   00CE A2 98               788 	mov	c,_RI
   00D0 E4                  789 	clr	a
   00D1 33                  790 	rlc	a
   00D2 F5 82               791 	mov	dpl,a
   00D4 22                  792 	ret
                            793 ;------------------------------------------------------------
                            794 ;Allocation info for local variables in function 'uart_s_write'
                            795 ;------------------------------------------------------------
                            796 ;c                         Allocated to registers 
                            797 ;------------------------------------------------------------
                            798 ;	./include/serial.h:32: void uart_s_write(unsigned char c) {
                            799 ;	-----------------------------------------
                            800 ;	 function uart_s_write
                            801 ;	-----------------------------------------
   00D5                     802 _uart_s_write:
   00D5 85 82 99            803 	mov	_SBUF,dpl
                            804 ;	./include/serial.h:34: TI = 0;
   00D8 C2 99               805 	clr	_TI
                            806 ;	./include/serial.h:35: while(!TI);
   00DA                     807 00101$:
   00DA 30 99 FD            808 	jnb	_TI,00101$
   00DD 22                  809 	ret
                            810 ;------------------------------------------------------------
                            811 ;Allocation info for local variables in function 'uart_s_read'
                            812 ;------------------------------------------------------------
                            813 ;------------------------------------------------------------
                            814 ;	./include/serial.h:38: unsigned char uart_s_read() {
                            815 ;	-----------------------------------------
                            816 ;	 function uart_s_read
                            817 ;	-----------------------------------------
   00DE                     818 _uart_s_read:
                            819 ;	./include/serial.h:39: while(!RI);
   00DE                     820 00101$:
                            821 ;	./include/serial.h:40: RI = 0;
   00DE 10 98 02            822 	jbc	_RI,00108$
   00E1 80 FB               823 	sjmp	00101$
   00E3                     824 00108$:
                            825 ;	./include/serial.h:41: return SBUF;
   00E3 85 99 82            826 	mov	dpl,_SBUF
   00E6 22                  827 	ret
                            828 ;------------------------------------------------------------
                            829 ;Allocation info for local variables in function 'type'
                            830 ;------------------------------------------------------------
                            831 ;str                       Allocated to registers r2 r3 r4 
                            832 ;------------------------------------------------------------
                            833 ;	./include/serial.h:44: void type(char* str) {
                            834 ;	-----------------------------------------
                            835 ;	 function type
                            836 ;	-----------------------------------------
   00E7                     837 _type:
   00E7 AA 82               838 	mov	r2,dpl
   00E9 AB 83               839 	mov	r3,dph
   00EB AC F0               840 	mov	r4,b
                            841 ;	./include/serial.h:45: while(*str)
   00ED                     842 00101$:
   00ED 8A 82               843 	mov	dpl,r2
   00EF 8B 83               844 	mov	dph,r3
   00F1 8C F0               845 	mov	b,r4
   00F3 12s00r00            846 	lcall	__gptrget
   00F6 FD                  847 	mov	r5,a
   00F7 60 18               848 	jz	00104$
                            849 ;	./include/serial.h:46: uart_s_write(*str++);
   00F9 0A                  850 	inc	r2
   00FA BA 00 01            851 	cjne	r2,#0x00,00110$
   00FD 0B                  852 	inc	r3
   00FE                     853 00110$:
   00FE 8D 82               854 	mov	dpl,r5
   0100 C0 02               855 	push	ar2
   0102 C0 03               856 	push	ar3
   0104 C0 04               857 	push	ar4
   0106 12s00rD5            858 	lcall	_uart_s_write
   0109 D0 04               859 	pop	ar4
   010B D0 03               860 	pop	ar3
   010D D0 02               861 	pop	ar2
   010F 80 DC               862 	sjmp	00101$
   0111                     863 00104$:
   0111 22                  864 	ret
                            865 ;------------------------------------------------------------
                            866 ;Allocation info for local variables in function 'is_queue_empty'
                            867 ;------------------------------------------------------------
                            868 ;------------------------------------------------------------
                            869 ;	./include/kb.h:23: unsigned char is_queue_empty(){
                            870 ;	-----------------------------------------
                            871 ;	 function is_queue_empty
                            872 ;	-----------------------------------------
   0112                     873 _is_queue_empty:
                            874 ;	./include/kb.h:24: return start_queue == end_queue;
   0112 E5*3D               875 	mov	a,_end_queue
   0114 B5*3C 04            876 	cjne	a,_start_queue,00103$
   0117 74 01               877 	mov	a,#0x01
   0119 80 01               878 	sjmp	00104$
   011B                     879 00103$:
   011B E4                  880 	clr	a
   011C                     881 00104$:
   011C F5 82               882 	mov	dpl,a
   011E 22                  883 	ret
                            884 ;------------------------------------------------------------
                            885 ;Allocation info for local variables in function 'capture_input'
                            886 ;------------------------------------------------------------
                            887 ;c                         Allocated to registers r2 
                            888 ;------------------------------------------------------------
                            889 ;	./include/kb.h:27: void capture_input(unsigned char c) {
                            890 ;	-----------------------------------------
                            891 ;	 function capture_input
                            892 ;	-----------------------------------------
   011F                     893 _capture_input:
   011F AA 82               894 	mov	r2,dpl
                            895 ;	./include/kb.h:28: if (start_queue == QUEUE_LENGTH)
   0121 74 0A               896 	mov	a,#0x0A
   0123 B5*3C 03            897 	cjne	a,_start_queue,00102$
                            898 ;	./include/kb.h:29: start_queue = 0;
   0126 75*3C 00            899 	mov	_start_queue,#0x00
   0129                     900 00102$:
                            901 ;	./include/kb.h:30: queue[start_queue++] = c;
   0129 AB*3C               902 	mov	r3,_start_queue
   012B 05*3C               903 	inc	_start_queue
   012D EB                  904 	mov	a,r3
   012E 24r32               905 	add	a,#_queue
   0130 F8                  906 	mov	r0,a
   0131 A6 02               907 	mov	@r0,ar2
   0133 22                  908 	ret
                            909 ;------------------------------------------------------------
                            910 ;Allocation info for local variables in function 'get_input'
                            911 ;------------------------------------------------------------
                            912 ;------------------------------------------------------------
                            913 ;	./include/kb.h:33: unsigned char get_input() {
                            914 ;	-----------------------------------------
                            915 ;	 function get_input
                            916 ;	-----------------------------------------
   0134                     917 _get_input:
                            918 ;	./include/kb.h:34: if (end_queue == QUEUE_LENGTH)
   0134 74 0A               919 	mov	a,#0x0A
   0136 B5*3D 03            920 	cjne	a,_end_queue,00102$
                            921 ;	./include/kb.h:35: end_queue = 0;
   0139 75*3D 00            922 	mov	_end_queue,#0x00
   013C                     923 00102$:
                            924 ;	./include/kb.h:36: return queue[end_queue++];
   013C AA*3D               925 	mov	r2,_end_queue
   013E 05*3D               926 	inc	_end_queue
   0140 EA                  927 	mov	a,r2
   0141 24r32               928 	add	a,#_queue
   0143 F8                  929 	mov	r0,a
   0144 86 82               930 	mov	dpl,@r0
   0146 22                  931 	ret
                            932 ;------------------------------------------------------------
                            933 ;Allocation info for local variables in function 'invalid_input'
                            934 ;------------------------------------------------------------
                            935 ;i                         Allocated to registers r2 
                            936 ;j                         Allocated to registers r5 
                            937 ;------------------------------------------------------------
                            938 ;	./include/kb.h:39: void invalid_input(){
                            939 ;	-----------------------------------------
                            940 ;	 function invalid_input
                            941 ;	-----------------------------------------
   0147                     942 _invalid_input:
                            943 ;	./include/kb.h:41: EA = 0;
   0147 C2 AF               944 	clr	_EA
                            945 ;	./include/kb.h:42: type("too many buttons\r\n");
   0149 90s00r03            946 	mov	dptr,#__str_0
   014C 75 F0 80            947 	mov	b,#0x80
   014F 12s00rE7            948 	lcall	_type
                            949 ;	./include/kb.h:43: for(i = 0; i < 4; i++) {
   0152 7A 00               950 	mov	r2,#0x00
   0154                     951 00105$:
   0154 BA 04 00            952 	cjne	r2,#0x04,00117$
   0157                     953 00117$:
   0157 50 2B               954 	jnc	00108$
                            955 ;	./include/kb.h:44: for(j = 0; j < 4; j++){
   0159 EA                  956 	mov	a,r2
   015A 2A                  957 	add	a,r2
   015B 25 E0               958 	add	a,acc
   015D 24r02               959 	add	a,#_bounce
   015F FB                  960 	mov	r3,a
   0160 EA                  961 	mov	a,r2
   0161 C4                  962 	swap	a
   0162 03                  963 	rr	a
   0163 54 F8               964 	anl	a,#0xf8
   0165 24r12               965 	add	a,#_time
   0167 FC                  966 	mov	r4,a
   0168 7D 00               967 	mov	r5,#0x00
   016A                     968 00101$:
   016A BD 04 00            969 	cjne	r5,#0x04,00119$
   016D                     970 00119$:
   016D 50 12               971 	jnc	00107$
                            972 ;	./include/kb.h:45: bounce[i][j] = 0;
   016F ED                  973 	mov	a,r5
   0170 2B                  974 	add	a,r3
   0171 F8                  975 	mov	r0,a
   0172 76 00               976 	mov	@r0,#0x00
                            977 ;	./include/kb.h:46: time[i][j] = 0;
   0174 ED                  978 	mov	a,r5
   0175 2D                  979 	add	a,r5
   0176 FE                  980 	mov	r6,a
   0177 2C                  981 	add	a,r4
   0178 F8                  982 	mov	r0,a
   0179 76 00               983 	mov	@r0,#0x00
   017B 08                  984 	inc	r0
   017C 76 00               985 	mov	@r0,#0x00
                            986 ;	./include/kb.h:44: for(j = 0; j < 4; j++){
   017E 0D                  987 	inc	r5
   017F 80 E9               988 	sjmp	00101$
   0181                     989 00107$:
                            990 ;	./include/kb.h:43: for(i = 0; i < 4; i++) {
   0181 0A                  991 	inc	r2
   0182 80 D0               992 	sjmp	00105$
   0184                     993 00108$:
                            994 ;	./include/kb.h:49: EA = 1;
   0184 D2 AF               995 	setb	_EA
   0186 22                  996 	ret
                            997 ;------------------------------------------------------------
                            998 ;Allocation info for local variables in function 'scan_row'
                            999 ;------------------------------------------------------------
                           1000 ;col                       Allocated to registers r2 
                           1001 ;row                       Allocated to registers r2 
                           1002 ;------------------------------------------------------------
                           1003 ;	./include/kb.h:52: unsigned char scan_row() {
                           1004 ;	-----------------------------------------
                           1005 ;	 function scan_row
                           1006 ;	-----------------------------------------
   0187                    1007 _scan_row:
                           1008 ;	./include/kb.h:55: if (column == 3)
   0187 74 03              1009 	mov	a,#0x03
   0189 B5*01 05           1010 	cjne	a,_column,00102$
                           1011 ;	./include/kb.h:56: column = 0;
   018C 75*01 00           1012 	mov	_column,#0x00
   018F 80 02              1013 	sjmp	00103$
   0191                    1014 00102$:
                           1015 ;	./include/kb.h:57: else column++;
   0191 05*01              1016 	inc	_column
   0193                    1017 00103$:
                           1018 ;	./include/kb.h:59: col = 0x1 << column; //0001,0010,0100,1000,0001,...
   0193 85*01 F0           1019 	mov	b,_column
   0196 05 F0              1020 	inc	b
   0198 74 01              1021 	mov	a,#0x01
   019A 80 02              1022 	sjmp	00111$
   019C                    1023 00109$:
   019C 25 E0              1024 	add	a,acc
   019E                    1025 00111$:
   019E D5 F0 FB           1026 	djnz	b,00109$
                           1027 ;	./include/kb.h:60: write_max(KB, ~col); //11111110,11111101,11111011,11110111,11111110,...
   01A1 F4                 1028 	cpl	a
   01A2 FA                 1029 	mov	r2,a
   01A3 C0 02              1030 	push	ar2
   01A5 90 00 00           1031 	mov	dptr,#0x0000
   01A8 12s00r38           1032 	lcall	_write_max
   01AB 15 81              1033 	dec	sp
                           1034 ;	./include/kb.h:62: row = read_max(KB) & (0xF0);
   01AD 90 00 00           1035 	mov	dptr,#0x0000
   01B0 12s00r4E           1036 	lcall	_read_max
                           1037 ;	./include/kb.h:63: row = (~(row >> 4)) & 0x0F;
   01B3 E5 82              1038 	mov	a,dpl
   01B5 54 F0              1039 	anl	a,#0xF0
   01B7 C4                 1040 	swap	a
   01B8 54 0F              1041 	anl	a,#0x0f
   01BA F4                 1042 	cpl	a
   01BB FB                 1043 	mov	r3,a
   01BC 74 0F              1044 	mov	a,#0x0F
   01BE 5B                 1045 	anl	a,r3
                           1046 ;	./include/kb.h:64: return row;
   01BF F5 82              1047 	mov	dpl,a
   01C1 22                 1048 	ret
                           1049 ;------------------------------------------------------------
                           1050 ;Allocation info for local variables in function 'timer_kb'
                           1051 ;------------------------------------------------------------
                           1052 ;row                       Allocated to registers r4 
                           1053 ;scanned_row               Allocated to stack - offset 1
                           1054 ;key_pressed               Allocated to registers r3 
                           1055 ;i                         Allocated to registers r2 
                           1056 ;j                         Allocated to registers r7 
                           1057 ;------------------------------------------------------------
                           1058 ;	./include/kb.h:67: void timer_kb(void) __interrupt( 1 ) {
                           1059 ;	-----------------------------------------
                           1060 ;	 function timer_kb
                           1061 ;	-----------------------------------------
   01C2                    1062 _timer_kb:
   01C2 C0*00              1063 	push	bits
   01C4 C0 E0              1064 	push	acc
   01C6 C0 F0              1065 	push	b
   01C8 C0 82              1066 	push	dpl
   01CA C0 83              1067 	push	dph
   01CC C0 02              1068 	push	(0+2)
   01CE C0 03              1069 	push	(0+3)
   01D0 C0 04              1070 	push	(0+4)
   01D2 C0 05              1071 	push	(0+5)
   01D4 C0 06              1072 	push	(0+6)
   01D6 C0 07              1073 	push	(0+7)
   01D8 C0 00              1074 	push	(0+0)
   01DA C0 01              1075 	push	(0+1)
   01DC C0 D0              1076 	push	psw
   01DE 75 D0 00           1077 	mov	psw,#0x00
   01E1 C0*00              1078 	push	_bp
   01E3 85 81*00           1079 	mov	_bp,sp
   01E6 05 81              1080 	inc	sp
                           1081 ;	./include/kb.h:71: scanned_row = scan_row();
   01E8 12s01r87           1082 	lcall	_scan_row
   01EB AA 82              1083 	mov	r2,dpl
   01ED A8*00              1084 	mov	r0,_bp
   01EF 08                 1085 	inc	r0
   01F0 A6 02              1086 	mov	@r0,ar2
                           1087 ;	./include/kb.h:72: key_pressed = 0;
   01F2 7B 00              1088 	mov	r3,#0x00
                           1089 ;	./include/kb.h:73: for (row = 0; row < 4; row++) {
   01F4 7C 00              1090 	mov	r4,#0x00
   01F6                    1091 00131$:
   01F6 BC 04 00           1092 	cjne	r4,#0x04,00155$
   01F9                    1093 00155$:
   01F9 40 03              1094 	jc	00156$
   01FB 02s03r8E           1095 	ljmp	00134$
   01FE                    1096 00156$:
                           1097 ;	./include/kb.h:74: if (scanned_row & (0x01 << row)) {
   01FE C0 03              1098 	push	ar3
   0200 8C F0              1099 	mov	b,r4
   0202 05 F0              1100 	inc	b
   0204 7D 01              1101 	mov	r5,#0x01
   0206 7E 00              1102 	mov	r6,#0x00
   0208 80 06              1103 	sjmp	00158$
   020A                    1104 00157$:
   020A ED                 1105 	mov	a,r5
   020B 2D                 1106 	add	a,r5
   020C FD                 1107 	mov	r5,a
   020D EE                 1108 	mov	a,r6
   020E 33                 1109 	rlc	a
   020F FE                 1110 	mov	r6,a
   0210                    1111 00158$:
   0210 D5 F0 F7           1112 	djnz	b,00157$
   0213 A8*00              1113 	mov	r0,_bp
   0215 08                 1114 	inc	r0
   0216 86 07              1115 	mov	ar7,@r0
   0218 7B 00              1116 	mov	r3,#0x00
   021A EF                 1117 	mov	a,r7
   021B 52 05              1118 	anl	ar5,a
   021D EB                 1119 	mov	a,r3
   021E 52 06              1120 	anl	ar6,a
   0220 D0 03              1121 	pop	ar3
   0222 ED                 1122 	mov	a,r5
   0223 4E                 1123 	orl	a,r6
   0224 60 42              1124 	jz	00110$
                           1125 ;	./include/kb.h:75: if (bounce[row][column] < 3)
   0226 EC                 1126 	mov	a,r4
   0227 2C                 1127 	add	a,r4
   0228 25 E0              1128 	add	a,acc
   022A FD                 1129 	mov	r5,a
   022B 24r02              1130 	add	a,#_bounce
   022D FE                 1131 	mov	r6,a
   022E E5*01              1132 	mov	a,_column
   0230 2E                 1133 	add	a,r6
   0231 F8                 1134 	mov	r0,a
   0232 86 06              1135 	mov	ar6,@r0
   0234 BE 03 00           1136 	cjne	r6,#0x03,00160$
   0237                    1137 00160$:
   0237 50 0E              1138 	jnc	00102$
                           1139 ;	./include/kb.h:76: bounce[row][column]++;
   0239 ED                 1140 	mov	a,r5
   023A 24r02              1141 	add	a,#_bounce
   023C FD                 1142 	mov	r5,a
   023D E5*01              1143 	mov	a,_column
   023F 2D                 1144 	add	a,r5
   0240 F8                 1145 	mov	r0,a
   0241 E6                 1146 	mov	a,@r0
   0242 FD                 1147 	mov	r5,a
   0243 04                 1148 	inc	a
   0244 F6                 1149 	mov	@r0,a
   0245 80 62              1150 	sjmp	00146$
   0247                    1151 00102$:
                           1152 ;	./include/kb.h:78: time[row][column]++;
   0247 EC                 1153 	mov	a,r4
   0248 C4                 1154 	swap	a
   0249 03                 1155 	rr	a
   024A 54 F8              1156 	anl	a,#0xf8
   024C 24r12              1157 	add	a,#_time
   024E FD                 1158 	mov	r5,a
   024F E5*01              1159 	mov	a,_column
   0251 25*01              1160 	add	a,_column
   0253 2D                 1161 	add	a,r5
   0254 F8                 1162 	mov	r0,a
   0255 86 05              1163 	mov	ar5,@r0
   0257 08                 1164 	inc	r0
   0258 86 06              1165 	mov	ar6,@r0
   025A 18                 1166 	dec	r0
   025B 0D                 1167 	inc	r5
   025C BD 00 01           1168 	cjne	r5,#0x00,00162$
   025F 0E                 1169 	inc	r6
   0260                    1170 00162$:
   0260 A6 05              1171 	mov	@r0,ar5
   0262 08                 1172 	inc	r0
   0263 A6 06              1173 	mov	@r0,ar6
   0265 18                 1174 	dec	r0
   0266 80 41              1175 	sjmp	00146$
   0268                    1176 00110$:
                           1177 ;	./include/kb.h:81: if (bounce[row][column] > 0)
   0268 EC                 1178 	mov	a,r4
   0269 2C                 1179 	add	a,r4
   026A 25 E0              1180 	add	a,acc
   026C FD                 1181 	mov	r5,a
   026D 24r02              1182 	add	a,#_bounce
   026F FE                 1183 	mov	r6,a
   0270 E5*01              1184 	mov	a,_column
   0272 2E                 1185 	add	a,r6
   0273 F8                 1186 	mov	r0,a
   0274 E6                 1187 	mov	a,@r0
   0275 60 0C              1188 	jz	00107$
                           1189 ;	./include/kb.h:82: bounce[row][column] = 0;
   0277 ED                 1190 	mov	a,r5
   0278 24r02              1191 	add	a,#_bounce
   027A FD                 1192 	mov	r5,a
   027B E5*01              1193 	mov	a,_column
   027D 2D                 1194 	add	a,r5
   027E F8                 1195 	mov	r0,a
   027F 76 00              1196 	mov	@r0,#0x00
   0281 80 26              1197 	sjmp	00146$
   0283                    1198 00107$:
                           1199 ;	./include/kb.h:83: else if (time[row][column] > 0)
   0283 EC                 1200 	mov	a,r4
   0284 C4                 1201 	swap	a
   0285 03                 1202 	rr	a
   0286 54 F8              1203 	anl	a,#0xf8
   0288 FD                 1204 	mov	r5,a
   0289 24r12              1205 	add	a,#_time
   028B FE                 1206 	mov	r6,a
   028C E5*01              1207 	mov	a,_column
   028E 25*01              1208 	add	a,_column
   0290 FF                 1209 	mov	r7,a
   0291 2E                 1210 	add	a,r6
   0292 F8                 1211 	mov	r0,a
   0293 86 06              1212 	mov	ar6,@r0
   0295 08                 1213 	inc	r0
   0296 86 02              1214 	mov	ar2,@r0
   0298 18                 1215 	dec	r0
   0299 EE                 1216 	mov	a,r6
   029A 4A                 1217 	orl	a,r2
   029B 60 0C              1218 	jz	00146$
                           1219 ;	./include/kb.h:84: time[row][column] = 0;
   029D ED                 1220 	mov	a,r5
   029E 24r12              1221 	add	a,#_time
   02A0 FD                 1222 	mov	r5,a
   02A1 EF                 1223 	mov	a,r7
   02A2 2D                 1224 	add	a,r5
   02A3 F8                 1225 	mov	r0,a
   02A4 76 00              1226 	mov	@r0,#0x00
   02A6 08                 1227 	inc	r0
   02A7 76 00              1228 	mov	@r0,#0x00
                           1229 ;	./include/kb.h:87: for(i = 0; i < 4; i++) {
   02A9                    1230 00146$:
   02A9 7A 00              1231 	mov	r2,#0x00
   02AB                    1232 00127$:
   02AB BA 04 00           1233 	cjne	r2,#0x04,00165$
   02AE                    1234 00165$:
   02AE 50 2D              1235 	jnc	00130$
                           1236 ;	./include/kb.h:88: for(j = 0; j < 4; j++) {
   02B0 EA                 1237 	mov	a,r2
   02B1 2A                 1238 	add	a,r2
   02B2 25 E0              1239 	add	a,acc
   02B4 24r02              1240 	add	a,#_bounce
   02B6 FD                 1241 	mov	r5,a
   02B7 8B 06              1242 	mov	ar6,r3
   02B9 7F 00              1243 	mov	r7,#0x00
   02BB                    1244 00123$:
   02BB BF 04 00           1245 	cjne	r7,#0x04,00167$
   02BE                    1246 00167$:
   02BE 50 18              1247 	jnc	00152$
                           1248 ;	./include/kb.h:89: if(bounce[i][j] == 3)
   02C0 C0 02              1249 	push	ar2
   02C2 EF                 1250 	mov	a,r7
   02C3 2D                 1251 	add	a,r5
   02C4 F8                 1252 	mov	r0,a
   02C5 86 02              1253 	mov	ar2,@r0
   02C7 BA 03 02           1254 	cjne	r2,#0x03,00169$
   02CA 80 04              1255 	sjmp	00170$
   02CC                    1256 00169$:
   02CC D0 02              1257 	pop	ar2
   02CE 80 05              1258 	sjmp	00125$
   02D0                    1259 00170$:
   02D0 D0 02              1260 	pop	ar2
                           1261 ;	./include/kb.h:90: key_pressed++;
   02D2 0E                 1262 	inc	r6
   02D3 8E 03              1263 	mov	ar3,r6
   02D5                    1264 00125$:
                           1265 ;	./include/kb.h:88: for(j = 0; j < 4; j++) {
   02D5 0F                 1266 	inc	r7
   02D6 80 E3              1267 	sjmp	00123$
   02D8                    1268 00152$:
   02D8 8E 03              1269 	mov	ar3,r6
                           1270 ;	./include/kb.h:87: for(i = 0; i < 4; i++) {
   02DA 0A                 1271 	inc	r2
   02DB 80 CE              1272 	sjmp	00127$
   02DD                    1273 00130$:
                           1274 ;	./include/kb.h:94: leds(key_pressed);
   02DD 8B 82              1275 	mov	dpl,r3
   02DF C0 03              1276 	push	ar3
   02E1 C0 04              1277 	push	ar4
   02E3 12s00rAE           1278 	lcall	_leds
   02E6 D0 04              1279 	pop	ar4
   02E8 D0 03              1280 	pop	ar3
                           1281 ;	./include/kb.h:95: if (key_pressed > MAX_KEYS_PRESSED)
   02EA EB                 1282 	mov	a,r3
   02EB 24 FD              1283 	add	a,#0xff - 0x02
   02ED 50 0E              1284 	jnc	00121$
                           1285 ;	./include/kb.h:96: invalid_input();
   02EF C0 03              1286 	push	ar3
   02F1 C0 04              1287 	push	ar4
   02F3 12s01r47           1288 	lcall	_invalid_input
   02F6 D0 04              1289 	pop	ar4
   02F8 D0 03              1290 	pop	ar3
   02FA 02s03r8A           1291 	ljmp	00133$
   02FD                    1292 00121$:
                           1293 ;	./include/kb.h:98: key_pressed = 0;
   02FD 7B 00              1294 	mov	r3,#0x00
                           1295 ;	./include/kb.h:99: if (bounce[row][column] >= 3 && time[row][column] == 1) {
   02FF EC                 1296 	mov	a,r4
   0300 2C                 1297 	add	a,r4
   0301 25 E0              1298 	add	a,acc
   0303 FA                 1299 	mov	r2,a
   0304 24r02              1300 	add	a,#_bounce
   0306 FD                 1301 	mov	r5,a
   0307 E5*01              1302 	mov	a,_column
   0309 2D                 1303 	add	a,r5
   030A F8                 1304 	mov	r0,a
   030B 86 05              1305 	mov	ar5,@r0
   030D BD 03 00           1306 	cjne	r5,#0x03,00172$
   0310                    1307 00172$:
   0310 40 31              1308 	jc	00117$
   0312 EC                 1309 	mov	a,r4
   0313 C4                 1310 	swap	a
   0314 03                 1311 	rr	a
   0315 54 F8              1312 	anl	a,#0xf8
   0317 24r12              1313 	add	a,#_time
   0319 FD                 1314 	mov	r5,a
   031A E5*01              1315 	mov	a,_column
   031C 25*01              1316 	add	a,_column
   031E 2D                 1317 	add	a,r5
   031F F8                 1318 	mov	r0,a
   0320 86 05              1319 	mov	ar5,@r0
   0322 08                 1320 	inc	r0
   0323 86 06              1321 	mov	ar6,@r0
   0325 18                 1322 	dec	r0
   0326 BD 01 1A           1323 	cjne	r5,#0x01,00117$
   0329 BE 00 17           1324 	cjne	r6,#0x00,00117$
                           1325 ;	./include/kb.h:100: capture_input(keyboard[row][column]);
   032C EA                 1326 	mov	a,r2
   032D 24r3E              1327 	add	a,#_keyboard
   032F FD                 1328 	mov	r5,a
   0330 E5*01              1329 	mov	a,_column
   0332 2D                 1330 	add	a,r5
   0333 F8                 1331 	mov	r0,a
   0334 86 82              1332 	mov	dpl,@r0
   0336 C0 03              1333 	push	ar3
   0338 C0 04              1334 	push	ar4
   033A 12s01r1F           1335 	lcall	_capture_input
   033D D0 04              1336 	pop	ar4
   033F D0 03              1337 	pop	ar3
   0341 80 47              1338 	sjmp	00133$
   0343                    1339 00117$:
                           1340 ;	./include/kb.h:102: else if (time[row][column] >= 15) {
   0343 EC                 1341 	mov	a,r4
   0344 C4                 1342 	swap	a
   0345 03                 1343 	rr	a
   0346 54 F8              1344 	anl	a,#0xf8
   0348 FD                 1345 	mov	r5,a
   0349 24r12              1346 	add	a,#_time
   034B FE                 1347 	mov	r6,a
   034C E5*01              1348 	mov	a,_column
   034E 25*01              1349 	add	a,_column
   0350 2E                 1350 	add	a,r6
   0351 F8                 1351 	mov	r0,a
   0352 86 06              1352 	mov	ar6,@r0
   0354 08                 1353 	inc	r0
   0355 86 07              1354 	mov	ar7,@r0
   0357 18                 1355 	dec	r0
   0358 C3                 1356 	clr	c
   0359 EE                 1357 	mov	a,r6
   035A 94 0F              1358 	subb	a,#0x0F
   035C EF                 1359 	mov	a,r7
   035D 94 00              1360 	subb	a,#0x00
   035F 40 29              1361 	jc	00133$
                           1362 ;	./include/kb.h:103: capture_input(keyboard[row][column]);
   0361 EA                 1363 	mov	a,r2
   0362 24r3E              1364 	add	a,#_keyboard
   0364 FA                 1365 	mov	r2,a
   0365 E5*01              1366 	mov	a,_column
   0367 2A                 1367 	add	a,r2
   0368 F8                 1368 	mov	r0,a
   0369 86 82              1369 	mov	dpl,@r0
   036B C0 03              1370 	push	ar3
   036D C0 04              1371 	push	ar4
   036F C0 05              1372 	push	ar5
   0371 12s01r1F           1373 	lcall	_capture_input
   0374 D0 05              1374 	pop	ar5
   0376 D0 04              1375 	pop	ar4
   0378 D0 03              1376 	pop	ar3
                           1377 ;	./include/kb.h:104: time[row][column] = 2;
   037A ED                 1378 	mov	a,r5
   037B 24r12              1379 	add	a,#_time
   037D FD                 1380 	mov	r5,a
   037E E5*01              1381 	mov	a,_column
   0380 25*01              1382 	add	a,_column
   0382 FA                 1383 	mov	r2,a
   0383 2D                 1384 	add	a,r5
   0384 F8                 1385 	mov	r0,a
   0385 76 02              1386 	mov	@r0,#0x02
   0387 08                 1387 	inc	r0
   0388 76 00              1388 	mov	@r0,#0x00
   038A                    1389 00133$:
                           1390 ;	./include/kb.h:73: for (row = 0; row < 4; row++) {
   038A 0C                 1391 	inc	r4
   038B 02s01rF6           1392 	ljmp	00131$
   038E                    1393 00134$:
                           1394 ;	./include/kb.h:108: TH0 = 0xED;    // T0 1kHz
   038E 75 8C ED           1395 	mov	_TH0,#0xED
                           1396 ;	./include/kb.h:109: TL0 = 0xBB;
   0391 75 8A BB           1397 	mov	_TL0,#0xBB
   0394 85*00 81           1398 	mov	sp,_bp
   0397 D0*00              1399 	pop	_bp
   0399 D0 D0              1400 	pop	psw
   039B D0 01              1401 	pop	(0+1)
   039D D0 00              1402 	pop	(0+0)
   039F D0 07              1403 	pop	(0+7)
   03A1 D0 06              1404 	pop	(0+6)
   03A3 D0 05              1405 	pop	(0+5)
   03A5 D0 04              1406 	pop	(0+4)
   03A7 D0 03              1407 	pop	(0+3)
   03A9 D0 02              1408 	pop	(0+2)
   03AB D0 83              1409 	pop	dph
   03AD D0 82              1410 	pop	dpl
   03AF D0 F0              1411 	pop	b
   03B1 D0 E0              1412 	pop	acc
   03B3 D0*00              1413 	pop	bits
   03B5 32                 1414 	reti
                           1415 ;------------------------------------------------------------
                           1416 ;Allocation info for local variables in function 'init_kb_timer'
                           1417 ;------------------------------------------------------------
                           1418 ;------------------------------------------------------------
                           1419 ;	./include/kb.h:112: void init_kb_timer(){
                           1420 ;	-----------------------------------------
                           1421 ;	 function init_kb_timer
                           1422 ;	-----------------------------------------
   03B6                    1423 _init_kb_timer:
                           1424 ;	./include/kb.h:113: SetVector(0x200B, (void*) timer_kb); // T0 int prog
   03B6 7ArC2              1425 	mov	r2,#_timer_kb
   03B8 7Bs01              1426 	mov	r3,#(_timer_kb >> 8)
   03BA 7C 80              1427 	mov	r4,#0x80
   03BC C0 02              1428 	push	ar2
   03BE C0 03              1429 	push	ar3
   03C0 C0 04              1430 	push	ar4
   03C2 90 20 0B           1431 	mov	dptr,#0x200B
   03C5 12s00r00           1432 	lcall	_SetVector
   03C8 15 81              1433 	dec	sp
   03CA 15 81              1434 	dec	sp
   03CC 15 81              1435 	dec	sp
                           1436 ;	./include/kb.h:114: TH0 = 0xED;    // T0 1kHz
   03CE 75 8C ED           1437 	mov	_TH0,#0xED
                           1438 ;	./include/kb.h:115: TL0 = 0xBB;
   03D1 75 8A BB           1439 	mov	_TL0,#0xBB
                           1440 ;	./include/kb.h:116: TMOD |= 0x01;  // T0 16 bit
   03D4 43 89 01           1441 	orl	_TMOD,#0x01
                           1442 ;	./include/kb.h:117: ET0 = 1;       // T0 int
   03D7 D2 A9              1443 	setb	_ET0
                           1444 ;	./include/kb.h:118: TR0 = 1;       // T0 run
   03D9 D2 8C              1445 	setb	_TR0
   03DB 22                 1446 	ret
                           1447 ;------------------------------------------------------------
                           1448 ;Allocation info for local variables in function 'print_error'
                           1449 ;------------------------------------------------------------
                           1450 ;------------------------------------------------------------
                           1451 ;	src/lab4.c:29: void print_error(){
                           1452 ;	-----------------------------------------
                           1453 ;	 function print_error
                           1454 ;	-----------------------------------------
   03DC                    1455 _print_error:
                           1456 ;	src/lab4.c:30: EA = 0;
   03DC C2 AF              1457 	clr	_EA
                           1458 ;	src/lab4.c:31: type(EOL);
   03DE 90s00r00           1459 	mov	dptr,#_EOL
   03E1 75 F0 80           1460 	mov	b,#0x80
   03E4 12s00rE7           1461 	lcall	_type
                           1462 ;	src/lab4.c:32: type("Invalid arguments.");
   03E7 90s00r16           1463 	mov	dptr,#__str_1
   03EA 75 F0 80           1464 	mov	b,#0x80
   03ED 12s00rE7           1465 	lcall	_type
                           1466 ;	src/lab4.c:33: type(EOL);
   03F0 90s00r00           1467 	mov	dptr,#_EOL
   03F3 75 F0 80           1468 	mov	b,#0x80
   03F6 12s00rE7           1469 	lcall	_type
                           1470 ;	src/lab4.c:34: EA = 1;
   03F9 D2 AF              1471 	setb	_EA
   03FB 22                 1472 	ret
                           1473 ;------------------------------------------------------------
                           1474 ;Allocation info for local variables in function 'print_num'
                           1475 ;------------------------------------------------------------
                           1476 ;num                       Allocated to registers r2 
                           1477 ;------------------------------------------------------------
                           1478 ;	src/lab4.c:37: void print_num(char num) {
                           1479 ;	-----------------------------------------
                           1480 ;	 function print_num
                           1481 ;	-----------------------------------------
   03FC                    1482 _print_num:
                           1483 ;	src/lab4.c:38: if(num < 0) {
   03FC E5 82              1484 	mov	a,dpl
   03FE FA                 1485 	mov	r2,a
   03FF 30 E7 0E           1486 	jnb	acc.7,00102$
                           1487 ;	src/lab4.c:39: uart_s_write('-');
   0402 75 82 2D           1488 	mov	dpl,#0x2D
   0405 C0 02              1489 	push	ar2
   0407 12s00rD5           1490 	lcall	_uart_s_write
   040A D0 02              1491 	pop	ar2
                           1492 ;	src/lab4.c:40: num *= -1;
   040C C3                 1493 	clr	c
   040D E4                 1494 	clr	a
   040E 9A                 1495 	subb	a,r2
   040F FA                 1496 	mov	r2,a
   0410                    1497 00102$:
                           1498 ;	src/lab4.c:42: if(num > 9) uart_s_write(num / 10 + '0');
   0410 C3                 1499 	clr	c
   0411 74 89              1500 	mov	a,#(0x09 ^ 0x80)
   0413 8A F0              1501 	mov	b,r2
   0415 63 F0 80           1502 	xrl	b,#0x80
   0418 95 F0              1503 	subb	a,b
   041A 50 1E              1504 	jnc	00104$
   041C C2 D5              1505 	clr	F0
   041E 75 F0 0A           1506 	mov	b,#0x0a
   0421 EA                 1507 	mov	a,r2
   0422 30 E7 04           1508 	jnb	acc.7,00111$
   0425 B2 D5              1509 	cpl	F0
   0427 F4                 1510 	cpl	a
   0428 04                 1511 	inc	a
   0429                    1512 00111$:
   0429 84                 1513 	div	ab
   042A 30 D5 02           1514 	jnb	F0,00112$
   042D F4                 1515 	cpl	a
   042E 04                 1516 	inc	a
   042F                    1517 00112$:
   042F 24 30              1518 	add	a,#0x30
   0431 F5 82              1519 	mov	dpl,a
   0433 C0 02              1520 	push	ar2
   0435 12s00rD5           1521 	lcall	_uart_s_write
   0438 D0 02              1522 	pop	ar2
   043A                    1523 00104$:
                           1524 ;	src/lab4.c:43: uart_s_write(num % 10 + '0');
   043A 75 F0 0A           1525 	mov	b,#0x0a
   043D EA                 1526 	mov	a,r2
   043E C2 D5              1527 	clr	F0
   0440 30 E7 04           1528 	jnb	acc.7,00113$
   0443 D2 D5              1529 	setb	F0
   0445 F4                 1530 	cpl	a
   0446 04                 1531 	inc	a
   0447                    1532 00113$:
   0447 84                 1533 	div	ab
   0448 E5 F0              1534 	mov	a,b
   044A 30 D5 02           1535 	jnb	F0,00114$
   044D F4                 1536 	cpl	a
   044E 04                 1537 	inc	a
   044F                    1538 00114$:
   044F 24 30              1539 	add	a,#0x30
   0451 F5 82              1540 	mov	dpl,a
   0453 02s00rD5           1541 	ljmp	_uart_s_write
                           1542 ;------------------------------------------------------------
                           1543 ;Allocation info for local variables in function 'print_result'
                           1544 ;------------------------------------------------------------
                           1545 ;array                     Allocated to stack - offset 1
                           1546 ;count                     Allocated to registers r2 r3 
                           1547 ;it                        Allocated to registers r2 r3 
                           1548 ;i                         Allocated to registers 
                           1549 ;------------------------------------------------------------
                           1550 ;	src/lab4.c:46: void print_result() {
                           1551 ;	-----------------------------------------
                           1552 ;	 function print_result
                           1553 ;	-----------------------------------------
   0456                    1554 _print_result:
   0456 C0*00              1555 	push	_bp
   0458 E5 81              1556 	mov	a,sp
   045A F5*00              1557 	mov	_bp,a
   045C 24 10              1558 	add	a,#0x10
   045E F5 81              1559 	mov	sp,a
                           1560 ;	src/lab4.c:47: int array[8] = {0, 0, 0, 0, 0, 0, 0, 0};
   0460 A8*00              1561 	mov	r0,_bp
   0462 08                 1562 	inc	r0
   0463 76 00              1563 	mov	@r0,#0x00
   0465 08                 1564 	inc	r0
   0466 76 00              1565 	mov	@r0,#0x00
   0468 18                 1566 	dec	r0
   0469 74 02              1567 	mov	a,#0x02
   046B 28                 1568 	add	a,r0
   046C F9                 1569 	mov	r1,a
   046D 77 00              1570 	mov	@r1,#0x00
   046F 09                 1571 	inc	r1
   0470 77 00              1572 	mov	@r1,#0x00
   0472 74 04              1573 	mov	a,#0x04
   0474 28                 1574 	add	a,r0
   0475 F9                 1575 	mov	r1,a
   0476 77 00              1576 	mov	@r1,#0x00
   0478 09                 1577 	inc	r1
   0479 77 00              1578 	mov	@r1,#0x00
   047B 74 06              1579 	mov	a,#0x06
   047D 28                 1580 	add	a,r0
   047E F9                 1581 	mov	r1,a
   047F 77 00              1582 	mov	@r1,#0x00
   0481 09                 1583 	inc	r1
   0482 77 00              1584 	mov	@r1,#0x00
   0484 74 08              1585 	mov	a,#0x08
   0486 28                 1586 	add	a,r0
   0487 F9                 1587 	mov	r1,a
   0488 77 00              1588 	mov	@r1,#0x00
   048A 09                 1589 	inc	r1
   048B 77 00              1590 	mov	@r1,#0x00
   048D 74 0A              1591 	mov	a,#0x0A
   048F 28                 1592 	add	a,r0
   0490 F9                 1593 	mov	r1,a
   0491 77 00              1594 	mov	@r1,#0x00
   0493 09                 1595 	inc	r1
   0494 77 00              1596 	mov	@r1,#0x00
   0496 74 0C              1597 	mov	a,#0x0C
   0498 28                 1598 	add	a,r0
   0499 F9                 1599 	mov	r1,a
   049A 77 00              1600 	mov	@r1,#0x00
   049C 09                 1601 	inc	r1
   049D 77 00              1602 	mov	@r1,#0x00
   049F 74 0E              1603 	mov	a,#0x0E
   04A1 28                 1604 	add	a,r0
   04A2 F9                 1605 	mov	r1,a
   04A3 77 00              1606 	mov	@r1,#0x00
   04A5 09                 1607 	inc	r1
   04A6 77 00              1608 	mov	@r1,#0x00
                           1609 ;	src/lab4.c:50: while (first_num > 0) {
   04A8 7A 00              1610 	mov	r2,#0x00
   04AA 7B 00              1611 	mov	r3,#0x00
   04AC                    1612 00101$:
   04AC C3                 1613 	clr	c
   04AD 74 80              1614 	mov	a,#(0x00 ^ 0x80)
   04AF 85*59 F0           1615 	mov	b,_first_num
   04B2 63 F0 80           1616 	xrl	b,#0x80
   04B5 95 F0              1617 	subb	a,b
   04B7 50 40              1618 	jnc	00103$
                           1619 ;	src/lab4.c:51: array[count] = first_num % 2;
   04B9 8A 04              1620 	mov	ar4,r2
   04BB EB                 1621 	mov	a,r3
   04BC CC                 1622 	xch	a,r4
   04BD 25 E0              1623 	add	a,acc
   04BF CC                 1624 	xch	a,r4
   04C0 33                 1625 	rlc	a
   04C1 FD                 1626 	mov	r5,a
   04C2 EC                 1627 	mov	a,r4
   04C3 28                 1628 	add	a,r0
   04C4 F9                 1629 	mov	r1,a
   04C5 E5*59              1630 	mov	a,_first_num
   04C7 A2 E7              1631 	mov	c,acc.7
   04C9 54 01              1632 	anl	a,#0x01
   04CB 60 04              1633 	jz	00117$
   04CD 50 02              1634 	jnc	00117$
   04CF 44 FE              1635 	orl	a,#0xfe
   04D1                    1636 00117$:
   04D1 FC                 1637 	mov	r4,a
   04D2 33                 1638 	rlc	a
   04D3 95 E0              1639 	subb	a,acc
   04D5 FD                 1640 	mov	r5,a
   04D6 A7 04              1641 	mov	@r1,ar4
   04D8 09                 1642 	inc	r1
   04D9 A7 05              1643 	mov	@r1,ar5
   04DB 19                 1644 	dec	r1
                           1645 ;	src/lab4.c:52: first_num = first_num / 2;
   04DC C2 D5              1646 	clr	F0
   04DE 75 F0 02           1647 	mov	b,#0x02
   04E1 E5*59              1648 	mov	a,_first_num
   04E3 30 E7 04           1649 	jnb	acc.7,00118$
   04E6 B2 D5              1650 	cpl	F0
   04E8 F4                 1651 	cpl	a
   04E9 04                 1652 	inc	a
   04EA                    1653 00118$:
   04EA 84                 1654 	div	ab
   04EB 30 D5 02           1655 	jnb	F0,00119$
   04EE F4                 1656 	cpl	a
   04EF 04                 1657 	inc	a
   04F0                    1658 00119$:
   04F0 F5*59              1659 	mov	_first_num,a
                           1660 ;	src/lab4.c:53: count++;
   04F2 0A                 1661 	inc	r2
   04F3 BA 00 B6           1662 	cjne	r2,#0x00,00101$
   04F6 0B                 1663 	inc	r3
   04F7 80 B3              1664 	sjmp	00101$
   04F9                    1665 00103$:
                           1666 ;	src/lab4.c:55: for (it = 7; it >= 0; it--) {
   04F9 7A 07              1667 	mov	r2,#0x07
   04FB 7B 00              1668 	mov	r3,#0x00
   04FD                    1669 00104$:
   04FD EB                 1670 	mov	a,r3
   04FE 20 E7 29           1671 	jb	acc.7,00107$
                           1672 ;	src/lab4.c:56: char i = array[it];
   0501 8A 04              1673 	mov	ar4,r2
   0503 EB                 1674 	mov	a,r3
   0504 CC                 1675 	xch	a,r4
   0505 25 E0              1676 	add	a,acc
   0507 CC                 1677 	xch	a,r4
   0508 33                 1678 	rlc	a
   0509 EC                 1679 	mov	a,r4
   050A 28                 1680 	add	a,r0
   050B F9                 1681 	mov	r1,a
   050C 87 04              1682 	mov	ar4,@r1
   050E 09                 1683 	inc	r1
   050F 87 05              1684 	mov	ar5,@r1
   0511 19                 1685 	dec	r1
   0512 8C 82              1686 	mov	dpl,r4
                           1687 ;	src/lab4.c:57: print_num(i);
   0514 C0 02              1688 	push	ar2
   0516 C0 03              1689 	push	ar3
   0518 C0 00              1690 	push	ar0
   051A 12s03rFC           1691 	lcall	_print_num
   051D D0 00              1692 	pop	ar0
   051F D0 03              1693 	pop	ar3
   0521 D0 02              1694 	pop	ar2
                           1695 ;	src/lab4.c:55: for (it = 7; it >= 0; it--) {
   0523 1A                 1696 	dec	r2
   0524 BA FF D6           1697 	cjne	r2,#0xff,00104$
   0527 1B                 1698 	dec	r3
   0528 80 D3              1699 	sjmp	00104$
   052A                    1700 00107$:
                           1701 ;	src/lab4.c:60: ir = 0;
   052A 75*56 00           1702 	mov	_ir,#0x00
                           1703 ;	src/lab4.c:61: type(EOL);
   052D 90s00r00           1704 	mov	dptr,#_EOL
   0530 75 F0 80           1705 	mov	b,#0x80
   0533 12s00rE7           1706 	lcall	_type
   0536 85*00 81           1707 	mov	sp,_bp
   0539 D0*00              1708 	pop	_bp
   053B 22                 1709 	ret
                           1710 ;------------------------------------------------------------
                           1711 ;Allocation info for local variables in function 'to_num'
                           1712 ;------------------------------------------------------------
                           1713 ;size                      Allocated to stack - offset -3
                           1714 ;fifo_pos                  Allocated to stack - offset -5
                           1715 ;num                       Allocated to registers r2 r3 r4 
                           1716 ;------------------------------------------------------------
                           1717 ;	src/lab4.c:64: static int to_num(char *num, unsigned char size, int fifo_pos) {
                           1718 ;	-----------------------------------------
                           1719 ;	 function to_num
                           1720 ;	-----------------------------------------
   053C                    1721 _to_num:
   053C C0*00              1722 	push	_bp
   053E 85 81*00           1723 	mov	_bp,sp
   0541 AA 82              1724 	mov	r2,dpl
   0543 AB 83              1725 	mov	r3,dph
   0545 AC F0              1726 	mov	r4,b
                           1727 ;	src/lab4.c:65: if(size == 3) *num = (READ_FIFO[fifo_pos] - '0') * 100 + (READ_FIFO[fifo_pos+1] - '0') *10 + (READ_FIFO[fifo_pos+2] - '0');
   0547 A8*00              1728 	mov	r0,_bp
   0549 18                 1729 	dec	r0
   054A 18                 1730 	dec	r0
   054B 18                 1731 	dec	r0
   054C B6 03 3D           1732 	cjne	@r0,#0x03,00105$
   054F E5*00              1733 	mov	a,_bp
   0551 24 FB              1734 	add	a,#0xfb
   0553 F9                 1735 	mov	r1,a
   0554 E7                 1736 	mov	a,@r1
   0555 24r4E              1737 	add	a,#_READ_FIFO
   0557 F8                 1738 	mov	r0,a
   0558 E6                 1739 	mov	a,@r0
   0559 24 D0              1740 	add	a,#0xd0
   055B 75 F0 64           1741 	mov	b,#0x64
   055E A4                 1742 	mul	ab
   055F FD                 1743 	mov	r5,a
   0560 E5*00              1744 	mov	a,_bp
   0562 24 FB              1745 	add	a,#0xfb
   0564 F8                 1746 	mov	r0,a
   0565 E6                 1747 	mov	a,@r0
   0566 FE                 1748 	mov	r6,a
   0567 04                 1749 	inc	a
   0568 24r4E              1750 	add	a,#_READ_FIFO
   056A F8                 1751 	mov	r0,a
   056B E6                 1752 	mov	a,@r0
   056C FF                 1753 	mov	r7,a
   056D 24 D0              1754 	add	a,#0xd0
   056F 75 F0 0A           1755 	mov	b,#0x0A
   0572 A4                 1756 	mul	ab
   0573 2D                 1757 	add	a,r5
   0574 FD                 1758 	mov	r5,a
   0575 74 02              1759 	mov	a,#0x02
   0577 2E                 1760 	add	a,r6
   0578 24r4E              1761 	add	a,#_READ_FIFO
   057A F8                 1762 	mov	r0,a
   057B E6                 1763 	mov	a,@r0
   057C FE                 1764 	mov	r6,a
   057D 24 D0              1765 	add	a,#0xd0
   057F 2D                 1766 	add	a,r5
   0580 FD                 1767 	mov	r5,a
   0581 8A 82              1768 	mov	dpl,r2
   0583 8B 83              1769 	mov	dph,r3
   0585 8C F0              1770 	mov	b,r4
   0587 12s00r00           1771 	lcall	__gptrput
   058A 80 4A              1772 	sjmp	00108$
   058C                    1773 00105$:
                           1774 ;	src/lab4.c:66: else if (size == 2) *num = (READ_FIFO[fifo_pos] - '0') * 10 + (READ_FIFO[fifo_pos+1] - '0');
   058C A8*00              1775 	mov	r0,_bp
   058E 18                 1776 	dec	r0
   058F 18                 1777 	dec	r0
   0590 18                 1778 	dec	r0
   0591 B6 02 2C           1779 	cjne	@r0,#0x02,00102$
   0594 E5*00              1780 	mov	a,_bp
   0596 24 FB              1781 	add	a,#0xfb
   0598 F9                 1782 	mov	r1,a
   0599 E7                 1783 	mov	a,@r1
   059A 24r4E              1784 	add	a,#_READ_FIFO
   059C F8                 1785 	mov	r0,a
   059D E6                 1786 	mov	a,@r0
   059E 24 D0              1787 	add	a,#0xd0
   05A0 75 F0 0A           1788 	mov	b,#0x0A
   05A3 A4                 1789 	mul	ab
   05A4 FD                 1790 	mov	r5,a
   05A5 E5*00              1791 	mov	a,_bp
   05A7 24 FB              1792 	add	a,#0xfb
   05A9 F8                 1793 	mov	r0,a
   05AA E6                 1794 	mov	a,@r0
   05AB 04                 1795 	inc	a
   05AC 24r4E              1796 	add	a,#_READ_FIFO
   05AE F8                 1797 	mov	r0,a
   05AF E6                 1798 	mov	a,@r0
   05B0 FE                 1799 	mov	r6,a
   05B1 24 D0              1800 	add	a,#0xd0
   05B3 2D                 1801 	add	a,r5
   05B4 FD                 1802 	mov	r5,a
   05B5 8A 82              1803 	mov	dpl,r2
   05B7 8B 83              1804 	mov	dph,r3
   05B9 8C F0              1805 	mov	b,r4
   05BB 12s00r00           1806 	lcall	__gptrput
   05BE 80 16              1807 	sjmp	00108$
   05C0                    1808 00102$:
                           1809 ;	src/lab4.c:67: else *num = READ_FIFO[fifo_pos] - '0';
   05C0 E5*00              1810 	mov	a,_bp
   05C2 24 FB              1811 	add	a,#0xfb
   05C4 F9                 1812 	mov	r1,a
   05C5 E7                 1813 	mov	a,@r1
   05C6 24r4E              1814 	add	a,#_READ_FIFO
   05C8 F8                 1815 	mov	r0,a
   05C9 E6                 1816 	mov	a,@r0
   05CA 24 D0              1817 	add	a,#0xd0
   05CC FD                 1818 	mov	r5,a
   05CD 8A 82              1819 	mov	dpl,r2
   05CF 8B 83              1820 	mov	dph,r3
   05D1 8C F0              1821 	mov	b,r4
   05D3 12s00r00           1822 	lcall	__gptrput
                           1823 ;	src/lab4.c:69: return -1;
   05D6                    1824 00108$:
                           1825 ;	src/lab4.c:71: return 0;
   05D6 90 00 00           1826 	mov	dptr,#0x0000
   05D9 D0*00              1827 	pop	_bp
   05DB 22                 1828 	ret
                           1829 ;------------------------------------------------------------
                           1830 ;Allocation info for local variables in function 'add_char'
                           1831 ;------------------------------------------------------------
                           1832 ;button                    Allocated to registers r2 
                           1833 ;------------------------------------------------------------
                           1834 ;	src/lab4.c:74: static int add_char(unsigned char button) {
                           1835 ;	-----------------------------------------
                           1836 ;	 function add_char
                           1837 ;	-----------------------------------------
   05DC                    1838 _add_char:
   05DC AA 82              1839 	mov	r2,dpl
                           1840 ;	src/lab4.c:75: READ_FIFO[ir++] = button;
   05DE AB*56              1841 	mov	r3,_ir
   05E0 05*56              1842 	inc	_ir
   05E2 EB                 1843 	mov	a,r3
   05E3 24r4E              1844 	add	a,#_READ_FIFO
   05E5 F8                 1845 	mov	r0,a
   05E6 A6 02              1846 	mov	@r0,ar2
                           1847 ;	src/lab4.c:76: if(READ_FIFO[ir - 1] == '*') {
   05E8 E5*56              1848 	mov	a,_ir
   05EA 14                 1849 	dec	a
   05EB 24r4E              1850 	add	a,#_READ_FIFO
   05ED F8                 1851 	mov	r0,a
   05EE 86 02              1852 	mov	ar2,@r0
   05F0 BA 2A 0C           1853 	cjne	r2,#0x2A,00104$
                           1854 ;	src/lab4.c:77: if(first_size == 0) return -1;
   05F3 E5*57              1855 	mov	a,_first_size
   05F5 70 04              1856 	jnz	00102$
   05F7 90 FF FF           1857 	mov	dptr,#0xFFFF
   05FA 22                 1858 	ret
   05FB                    1859 00102$:
                           1860 ;	src/lab4.c:78: return 2;
   05FB 90 00 02           1861 	mov	dptr,#0x0002
   05FE 22                 1862 	ret
   05FF                    1863 00104$:
                           1864 ;	src/lab4.c:80: first_size++;
   05FF 05*57              1865 	inc	_first_size
                           1866 ;	src/lab4.c:81: return 0;
   0601 90 00 00           1867 	mov	dptr,#0x0000
   0604 22                 1868 	ret
                           1869 ;------------------------------------------------------------
                           1870 ;Allocation info for local variables in function 'reset'
                           1871 ;------------------------------------------------------------
                           1872 ;------------------------------------------------------------
                           1873 ;	src/lab4.c:102: static void reset() {
                           1874 ;	-----------------------------------------
                           1875 ;	 function reset
                           1876 ;	-----------------------------------------
   0605                    1877 _reset:
                           1878 ;	src/lab4.c:103: state = ST_FIRST;
   0605 75*5B 00           1879 	mov	_state,#0x00
                           1880 ;	src/lab4.c:104: first_size = 0;
   0608 75*57 00           1881 	mov	_first_size,#0x00
                           1882 ;	src/lab4.c:105: second_size = 0;
   060B 75*58 00           1883 	mov	_second_size,#0x00
                           1884 ;	src/lab4.c:106: ir = 0;
   060E 75*56 00           1885 	mov	_ir,#0x00
                           1886 ;	src/lab4.c:107: ET0 = 1;
   0611 D2 A9              1887 	setb	_ET0
                           1888 ;	src/lab4.c:108: first_num = -1;
   0613 75*59 FF           1889 	mov	_first_num,#0xFF
                           1890 ;	src/lab4.c:109: second_num = -1;
   0616 75*5A FF           1891 	mov	_second_num,#0xFF
   0619 22                 1892 	ret
                           1893 ;------------------------------------------------------------
                           1894 ;Allocation info for local variables in function 'fail'
                           1895 ;------------------------------------------------------------
                           1896 ;------------------------------------------------------------
                           1897 ;	src/lab4.c:112: static void fail() {
                           1898 ;	-----------------------------------------
                           1899 ;	 function fail
                           1900 ;	-----------------------------------------
   061A                    1901 _fail:
                           1902 ;	src/lab4.c:113: reset();
   061A 12s06r05           1903 	lcall	_reset
                           1904 ;	src/lab4.c:114: type(EOL);
   061D 90s00r00           1905 	mov	dptr,#_EOL
   0620 75 F0 80           1906 	mov	b,#0x80
   0623 12s00rE7           1907 	lcall	_type
                           1908 ;	src/lab4.c:115: print_error();
   0626 02s03rDC           1909 	ljmp	_print_error
                           1910 ;------------------------------------------------------------
                           1911 ;Allocation info for local variables in function 'main'
                           1912 ;------------------------------------------------------------
                           1913 ;dip                       Allocated to registers r2 
                           1914 ;button                    Allocated to registers r3 
                           1915 ;j                         Allocated to registers 
                           1916 ;rc                        Allocated to registers r3 r4 
                           1917 ;------------------------------------------------------------
                           1918 ;	src/lab4.c:119: void main() {
                           1919 ;	-----------------------------------------
                           1920 ;	 function main
                           1921 ;	-----------------------------------------
   0629                    1922 _main:
                           1923 ;	src/lab4.c:123: uart_s_init(S9600);
   0629 90 00 FD           1924 	mov	dptr,#0x00FD
   062C 12s00rC1           1925 	lcall	_uart_s_init
                           1926 ;	src/lab4.c:124: init_kb_timer();
   062F 12s03rB6           1927 	lcall	_init_kb_timer
                           1928 ;	src/lab4.c:126: EA = 1;
   0632 D2 AF              1929 	setb	_EA
                           1930 ;	src/lab4.c:128: while (1) {
   0634                    1931 00119$:
                           1932 ;	src/lab4.c:129: dip = readdip();
   0634 12s00r5A           1933 	lcall	_readdip
   0637 AA 82              1934 	mov	r2,dpl
                           1935 ;	src/lab4.c:130: if (dip == NORMAL) {
   0639 BA FF 5E           1936 	cjne	r2,#0xFF,00116$
                           1937 ;	src/lab4.c:131: if (!is_queue_empty()) {
   063C 12s01r12           1938 	lcall	_is_queue_empty
   063F E5 82              1939 	mov	a,dpl
   0641 70 F1              1940 	jnz	00119$
                           1941 ;	src/lab4.c:132: ET0 = 0;
   0643 C2 A9              1942 	clr	_ET0
                           1943 ;	src/lab4.c:134: button = get_input();
   0645 12s01r34           1944 	lcall	_get_input
   0648 AB 82              1945 	mov	r3,dpl
                           1946 ;	src/lab4.c:135: if(button=='*') uart_s_write('=');
   064A BB 2A 0C           1947 	cjne	r3,#0x2A,00102$
   064D 75 82 3D           1948 	mov	dpl,#0x3D
   0650 C0 03              1949 	push	ar3
   0652 12s00rD5           1950 	lcall	_uart_s_write
   0655 D0 03              1951 	pop	ar3
   0657 80 09              1952 	sjmp	00103$
   0659                    1953 00102$:
                           1954 ;	src/lab4.c:136: else uart_s_write(button);
   0659 8B 82              1955 	mov	dpl,r3
   065B C0 03              1956 	push	ar3
   065D 12s00rD5           1957 	lcall	_uart_s_write
   0660 D0 03              1958 	pop	ar3
   0662                    1959 00103$:
                           1960 ;	src/lab4.c:138: rc = add_char(button);
   0662 8B 82              1961 	mov	dpl,r3
   0664 12s05rDC           1962 	lcall	_add_char
   0667 AB 82              1963 	mov	r3,dpl
                           1964 ;	src/lab4.c:139: if(rc < 0) {
   0669 E5 83              1965 	mov	a,dph
   066B FC                 1966 	mov	r4,a
   066C 30 E7 05           1967 	jnb	acc.7,00105$
                           1968 ;	src/lab4.c:140: fail();
   066F 12s06r1A           1969 	lcall	_fail
                           1970 ;	src/lab4.c:141: continue;
   0672 80 C0              1971 	sjmp	00119$
   0674                    1972 00105$:
                           1973 ;	src/lab4.c:151: if(rc==2) {
   0674 BB 02 1F           1974 	cjne	r3,#0x02,00107$
   0677 BC 00 1C           1975 	cjne	r4,#0x00,00107$
                           1976 ;	src/lab4.c:157: rc = to_num(&first_num, first_size, 0);
   067A E4                 1977 	clr	a
   067B C0 E0              1978 	push	acc
   067D C0 E0              1979 	push	acc
   067F C0*57              1980 	push	_first_size
   0681 90s00r59           1981 	mov	dptr,#_first_num
   0684 75 F0 40           1982 	mov	b,#0x40
   0687 12s05r3C           1983 	lcall	_to_num
   068A 15 81              1984 	dec	sp
   068C 15 81              1985 	dec	sp
   068E 15 81              1986 	dec	sp
                           1987 ;	src/lab4.c:158: print_result();
   0690 12s04r56           1988 	lcall	_print_result
                           1989 ;	src/lab4.c:159: reset();
   0693 12s06r05           1990 	lcall	_reset
   0696                    1991 00107$:
                           1992 ;	src/lab4.c:186: ET0 = 1;
   0696 D2 A9              1993 	setb	_ET0
   0698 80 9A              1994 	sjmp	00119$
   069A                    1995 00116$:
                           1996 ;	src/lab4.c:188: } else if (dip == DEBUG) {
   069A BA FE 20           1997 	cjne	r2,#0xFE,00113$
                           1998 ;	src/lab4.c:189: if (!is_queue_empty()) {
   069D 12s01r12           1999 	lcall	_is_queue_empty
   06A0 E5 82              2000 	mov	a,dpl
   06A2 60 03              2001 	jz	00141$
   06A4 02s06r34           2002 	ljmp	00119$
   06A7                    2003 00141$:
                           2004 ;	src/lab4.c:190: ET0 = 0;
   06A7 C2 A9              2005 	clr	_ET0
                           2006 ;	src/lab4.c:191: uart_s_write(get_input());
   06A9 12s01r34           2007 	lcall	_get_input
   06AC 12s00rD5           2008 	lcall	_uart_s_write
                           2009 ;	src/lab4.c:192: type(EOL);
   06AF 90s00r00           2010 	mov	dptr,#_EOL
   06B2 75 F0 80           2011 	mov	b,#0x80
   06B5 12s00rE7           2012 	lcall	_type
                           2013 ;	src/lab4.c:193: ET0 = 1;
   06B8 D2 A9              2014 	setb	_ET0
   06BA 02s06r34           2015 	ljmp	00119$
   06BD                    2016 00113$:
                           2017 ;	src/lab4.c:197: leds(0xAA);
   06BD 75 82 AA           2018 	mov	dpl,#0xAA
   06C0 12s00rAE           2019 	lcall	_leds
   06C3 02s06r34           2020 	ljmp	00119$
                           2021 	.area CSEG    (CODE)
                           2022 	.area CONST   (CODE)
   0000                    2023 _EOL:
   0000 0D                 2024 	.db #0x0D
   0001 0A                 2025 	.db #0x0A
   0002 00                 2026 	.db #0x00
   0003                    2027 __str_0:
   0003 74 6F 6F 20 6D 61  2028 	.ascii "too many buttons"
        6E 79 20 62 75 74
        74 6F 6E 73
   0013 0D                 2029 	.db 0x0D
   0014 0A                 2030 	.db 0x0A
   0015 00                 2031 	.db 0x00
   0016                    2032 __str_1:
   0016 49 6E 76 61 6C 69  2033 	.ascii "Invalid arguments."
        64 20 61 72 67 75
        6D 65 6E 74 73 2E
   0028 00                 2034 	.db 0x00
                           2035 	.area XINIT   (CODE)
                           2036 	.area CABS    (ABS,CODE)
